import copy
import logging
import time
from pathlib import Path
from typing import Any, Text, Dict, List, Optional, Tuple, Set, Union, TYPE_CHECKING

from ruamel.yaml import YAMLError

from rasax.community.legacy.exceptions import YamlException
from sqlalchemy import and_, or_

import rasax.community.legacy.constants
import rasax.community.legacy.core.constants
from rasax.community.legacy.core.domain import Domain as RasaDomain
from rasax.community.legacy.core.events import ActionExecuted, UserUttered, SlotSet
from rasax.community.legacy.core.training_data.story_reader.story_reader import (
    StoryParseError,
)

from rasax.community.legacy.core.training_data.story_reader.yaml_story_reader import (
    YAMLStoryReader,
    CORE_SCHEMA_FILE,
)
from rasax.community.legacy.core.training_data.story_writer.yaml_story_writer import (
    YAMLStoryWriter,
)
from rasax.community.legacy.core.training_data.structures import StoryStep, RuleStep

import rasax.community.config as rasa_x_config
import rasax.community.constants as constants
import rasax.community.utils.common as common_utils
import rasax.community.utils.io as io_utils
from rasax.community.data import FileFormat
from rasax.community.database.admin import User
from rasax.community.database.data import Story
from rasax.community.database.service import DbService
from rasax.community.services import background_dump_service
import rasax.community.utils.yaml
import rasax.community.legacy.utils.validation
import rasax.community.data

if TYPE_CHECKING:
    from sanic.request import Request

logger = logging.getLogger(__name__)


class StoryService(DbService):
    """Service to manage training and test stories."""

    def get_all_stories_dict(self, project_id: Text) -> Dict[Text, Any]:
        """Return a dictionary containing all stories and rules.

        Structure is the same as the Story YAML format.

        Args:
            project_id: Project ID to filter stories/rules by.

        Returns:
            Dictionary containing all stories and rules.
        """
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain = domain_service.get_merged_domain(project_id)
        stories = self.fetch_stories()
        writer = YAMLStoryWriter()

        step_list = []
        for story in stories.result:
            steps = self.get_story_steps(
                story["story"], domain=domain, skip_validation=True,
            )

            step_list.extend(steps)

        return writer.stories_to_yaml(step_list)

    @staticmethod
    def get_story_steps(
        story_string: Text,
        domain: Dict[Text, Any] = None,
        filename: Optional[Text] = None,
        expand_or_statements: bool = False,
        skip_validation: bool = False,
    ) -> List[StoryStep]:
        """Returns the stories contained inside a stories file.

        Also checks if the intents in the stories are in the provided domain. For each
        intent not present in the domain, a UserWarning is issued.

        Args:
            story_string: String representing the contents of a stories file.
            domain: Domain for defined stories.
            filename: Name of the file where the text contents come from.
            expand_or_statements: If `True` OR-statements in stories are expanded
                so that we have multiple stories each representing one branch of
                the OR-statements.
            skip_validation: If `True` validation of story_string will be skipped.

        Returns:
            `StoryStep` object for each story contained in the file.
        """
        # Domain is not needed in `StoryFileReader` when parsing stories, but
        # if none is provided there will be a UserWarning for each intent.
        if not domain:
            domain = {}
        else:
            domain = copy.deepcopy(domain)

        domain = RasaDomain.from_dict(domain)
        reader = YAMLStoryReader(
            domain, source_name=filename, expand_or_statements=expand_or_statements,
        )
        try:
            parsed_yaml = rasax.community.utils.yaml.read_yaml(story_string)
            rasax.community.data.validate_project_data_version(parsed_yaml)
            if not skip_validation:
                rasax.community.legacy.utils.validation.validate_yaml_schema(
                    story_string, CORE_SCHEMA_FILE
                )

            return reader.read_from_parsed_yaml(parsed_yaml)
        except (
            AttributeError,
            ValueError,
            YamlException,
            YAMLError,
            rasax.community.data.ProjectDataVersionError,
        ) as e:
            raise StoryParseError(
                "Invalid story format. Failed to parse "
                "'{}'\nError: {}".format(story_string, e)
            )

    def _get_stories_as_yaml_string(
        self, project_id: Text, stories: List[Dict[Text, Any]]
    ) -> Text:
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain = domain_service.get_merged_domain(project_id)

        writer = YAMLStoryWriter()
        steps_list = []
        is_test_story = any([story["is_test"] for story in stories])

        for story in stories:
            steps_list.extend(
                StoryService.get_story_steps(
                    story["story"],
                    filename=story["filename"],
                    domain=domain,
                    skip_validation=True,
                )
            )

        return writer.dumps(steps_list, is_test_story=is_test_story)

    def get_stories_as_string(
        self, project_id: Text, stories: List[Dict[Text, Any]],
    ) -> Text:
        """Returns multiple stories in a single YAML representation.

        The stories then look like as they would have been read from a single file.

        Args:
            project_id: Target project ID.
            stories: List of stories as dictionaries.

        Returns:
            Contents of a stories file, as a string.
        """
        return self._get_stories_as_yaml_string(project_id, stories)

    async def _extract_stories_yaml(
        self,
        story_string: Text,
        filename: Text,
        domain: Optional[Dict[Text, Any]],
        is_test: bool = False,
    ) -> List[Tuple[Text, StoryStep]]:
        """Extract stories from the text contents of a YAML file.

        Args:
            story_string: Stories in string form (YAML format).
            filename: Name of stories file.
            domain: Stories domain.
            is_test: `True` if the file contains test stories exclusively.

        Returns:
            List of tuples, each tuple containing a story in string form and
            its `StoryStep` representation.
        """
        writer = YAMLStoryWriter()

        # validate stories here because this is part of save_stories
        steps_list = self.get_story_steps(
            story_string, domain, filename, skip_validation=False,
        )

        results = []

        for steps in steps_list:
            if not steps.block_name:
                raise StoryParseError(
                    f"Invalid story format. Failed to parse '{story_string}'"
                )

            story_text = writer.dumps([steps], is_test_story=is_test)
            results.append((story_text, steps))

        return results

    async def save_stories(
        self,
        story_string: Text,
        team: Text,
        project_id: Text,
        username: Text,
        filename: Optional[Text] = None,
        dump_stories: bool = True,
        add_story_items_to_domain: bool = True,
        is_rule: bool = False,
        is_test: bool = False,
    ) -> List[Dict[Text, Any]]:
        """Saves stories or rules from string form as individual stories or rules.

        Args:
            story_string: Stories or rules in string form.
            team: User's team.
            project_id: Project ID to assign to new data.
            username: User name.
            filename: Filename to assign to new data created.
            dump_stories: If `True`, schedule a dumping of stories/rules to
                local files.
            add_story_items_to_domain: if `True`, add new story/rule items to
                the domain.
            is_rule: Identifies if `story_string` contains exclusively rules.
            is_test: Identifies if `story_string` contains exclusively test stories.

        Returns:
            List of stored stories or rules.
        """
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain = domain_service.get_merged_domain(project_id)

        if not filename:
            filename = self.assign_filename(team, is_rule, is_test)

        inserted = []
        processed_stories = await self._extract_stories_yaml(
            story_string, filename, domain, is_test
        )

        for story_text, steps in processed_stories:
            new_story = Story(
                name=steps.block_name,
                story=story_text,
                annotated_at=time.time(),
                user=username,
                filename=filename,
                is_rule=isinstance(steps, RuleStep),
                is_test=is_test,
            )

            self.add(new_story)

            self.flush()  # flush to get inserted story id
            if add_story_items_to_domain:
                await self.add_domain_items_for_story(
                    new_story.id, project_id, username
                )

            inserted.append(new_story.as_dict())

        if inserted:
            if dump_stories:
                background_dump_service.add_story_change(filename)
            return inserted
        else:
            return []

    def assign_filename(
        self, team: Text, is_rule: bool = False, is_test: bool = False,
    ) -> Text:
        """Assigns a filename to a story/rule for writing it to disk later.

        This is either taking the filename of the story/rule which was added to the
        database most recently. If no matching story is in the database then it takes
        the filename based on the default Rasa Open Source project layout.

        Args:
            team: Story/Rule creator's team.
            is_rule: `True` if we want to store a rule instead of a story.
            is_test: `True` if we want to store a test story instead of a regular one.

        Returns:
            Story/rule filename.
        """
        query = (
            self.query(Story.filename)
            .join(User)
            .filter(
                User.team == team, Story.is_rule == is_rule, Story.is_test == is_test
            )
        )

        oldest_file = query.order_by(Story.id.asc()).first()
        file_name = io_utils.get_project_directory()

        if oldest_file:
            file_name = file_name / oldest_file[0]
        else:
            if is_test:
                file_name = (
                    file_name
                    / rasa_x_config.default_test_stories_dir
                    / rasa_x_config.default_test_story_file_path
                )
            elif is_rule:
                file_name = (
                    file_name
                    / rasa_x_config.data_dir
                    / rasa_x_config.default_rules_filename
                )
            else:
                file_name = (
                    file_name
                    / rasa_x_config.data_dir
                    / rasa_x_config.default_stories_filename
                )

        return str(file_name.with_suffix(FileFormat.YAML.value))

    async def save_stories_from_files(
        self,
        story_files: Union[List[Text], Set[Text]],
        team: Text,
        project_id: Text,
        username: Text,
        is_test: bool = False,
    ) -> List[Dict[Text, Any]]:
        """Save stories from `story_files` to database."""
        from rasax.initialise import _read_data

        story_blocks = []

        for text_data, path in _read_data(list(story_files)):
            logger.debug(
                f"Injecting stories from file '{path}' to database (test stories: "
                f"{is_test})."
            )

            additional_blocks = await self.save_stories(
                text_data,
                team,
                project_id,
                username,
                path,
                dump_stories=False,
                add_story_items_to_domain=False,
                is_test=is_test,
            )
            story_blocks.extend(additional_blocks)

        await self.add_domain_items_for_stories(project_id, username)

        return story_blocks

    async def replace_stories(
        self,
        story_string: Text,
        team: Text,
        project_id: Text,
        username: Text,
        filename: Optional[Text] = None,
        dump_stories: bool = True,
        replace_rules: Optional[bool] = None,
    ) -> List[Dict[Text, Any]]:
        """Delete all existing stories/rules and insert new ones.

        Args:
            story_string: Stories or rules in string form.
            team: User's team.
            project_id: Project ID to assign to new data.
            username: User name.
            filename: Filename to assign to new data created.
            dump_stories: If `True`, schedule a dumping of stories/rules to local files.
            replace_rules: If `True`, remove only rules from DB before
                inserting new ones. If `False`, remove only stories.

        Returns:
            List of stored stories or rules.
        """
        self.delete_all_stories(replace_rules)

        saved_stories = await self.save_stories(
            story_string, team, project_id, username, filename, dump_stories,
        )
        return saved_stories

    def fetch_stories(
        self,
        text_query: Optional[Text] = None,
        field_query: Optional[List[Tuple[Text, bool]]] = None,
        id_query: Optional[List[int]] = None,
        filename: Optional[Text] = None,
        distinct: bool = True,
        fetch_rules: Optional[bool] = None,
        limit: Optional[int] = None,
        offset: Optional[int] = None,
        fetch_test_stories: Optional[bool] = False,
    ) -> common_utils.QueryResult:
        """Fetch (search) stories or rules stored in the database.

        Args:
            text_query: Text query for story/rule text.
            field_query: Field query to limit returned fields.
            id_query: If specified, only fetch stories/rules with these IDs.
            filename: Filter results by filename.
            distinct: Ensure results are unique.
            fetch_rules: If `False`, fetch stories only. If `True`, fetch rules only.
            limit: Limit number of results.
            offset: Number to offset results by.
            fetch_test_stories: If `False`, fetch regular stories only. If
                `True`, fetch test stories only.

        Returns:
            List of stories or rules in their dictionary representation.
        """
        if text_query:
            query = Story.story.like(f"%{text_query}%")
        else:
            query = True

        if id_query:
            query = and_(query, or_(Story.id == id for id in id_query))

        if filename:
            query = and_(query, Story.filename == filename)

        if fetch_rules is not None:
            query = and_(query, Story.is_rule == fetch_rules)

        if fetch_test_stories is not None:
            query = and_(query, Story.is_test == fetch_test_stories)

        columns = common_utils.get_columns_from_fields(field_query)
        stories = self.query(*common_utils.get_query_selectors(Story, columns)).filter(
            query
        )

        if distinct:
            stories = stories.distinct()

        total_stories = stories.count()

        stories = stories.order_by(Story.id.asc()).offset(offset).limit(limit).all()

        if columns:
            results = [
                common_utils.query_result_to_dict(s, field_query) for s in stories
            ]
        else:
            results = [t.as_dict() for t in stories]

        return common_utils.QueryResult(results, total_stories)

    @staticmethod
    def visualize_stories(stories: List[Dict[Text, Any]], domain: RasaDomain) -> Text:
        """Return a Graphviz visualization of one or more stories or rules.

        Args:
            stories: List of stories or rules.
            domain: Stories/rules domain.

        Returns:
            Stories/rules in Graphviz DOT format.
        """
        from networkx.drawing.nx_pydot import to_pydot
        from rasax.community.legacy.core.training_data.visualization import (
            visualize_stories,
        )

        parsed_story_steps = []

        for story in stories:
            steps_list = StoryService.get_story_steps(
                story["story"],
                domain.as_dict(),
                story["filename"],
                skip_validation=True,
                expand_or_statements=True,
            )
            parsed_story_steps.extend(steps_list)

        graph = visualize_stories(
            parsed_story_steps, domain, output_file=None, max_history=2
        )

        return to_pydot(graph).to_string()

    def fetch_story(
        self, story_id: Text, fetch_rule: Optional[bool] = None
    ) -> Optional[Dict[Text, Any]]:
        """Fetch a story or a rule.

        Args:
            story_id: ID of story or rule.
            fetch_rule: If `True`, fetch only rules. If `False`, fetch only stories.

        Returns:
            Dictionary representation of a story or rule.
        """
        story = self.query(Story).filter(Story.id == story_id)

        if fetch_rule is not None:
            story = story.filter(Story.is_rule == fetch_rule)

        story = story.first()

        if story is None:
            return None

        return story.as_dict()

    def delete_story(self, _id: Text, delete_rule: Optional[bool] = None) -> bool:
        """Delete a story or a rule.

        Args:
            _id: ID of story or rule.
            delete_rule: When `True`, delete only rules. When `False`, delete
                only stories.

        Returns:
            `True` if the story or rule with given ID was deleted.
        """
        query = self.query(Story).filter(Story.id == _id)

        if delete_rule is not None:
            query = query.filter(Story.is_rule == delete_rule)

        story = query.first()

        if story:
            background_dump_service.add_story_change(story.filename)
            self.delete(story)
            return True

        return False

    async def _fetch_domain_items_from_story(
        self, story_id: Text, project_id: Text
    ) -> Optional[Tuple[Set[Text], Set[Text], Set[Text], Set[Text]]]:
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain = domain_service.get_merged_domain(project_id)

        story = self.fetch_story(story_id)

        if not story:
            return None

        # skip validation here because stories were fetched from the database
        steps = self.get_story_steps(story["story"], domain, skip_validation=True)
        story_actions = set()
        story_intents = set()
        story_entities = set()
        story_slots = set()
        for step in steps:
            for e in step.events:
                if (
                    isinstance(e, ActionExecuted)
                    # exclude default actions and utter actions
                    and e.action_name
                    not in rasax.community.legacy.core.constants.DEFAULT_ACTION_NAMES
                    and not e.action_name.startswith(
                        rasax.community.legacy.constants.UTTER_PREFIX
                    )
                ):
                    story_actions.add(e.action_name)
                elif isinstance(e, UserUttered):
                    intent = e.intent
                    entities = e.entities
                    if intent:
                        story_intents.add(intent.get("name"))
                    if entities:
                        entity_names = [e["entity"] for e in entities]
                        story_entities.update(entity_names)
                elif isinstance(e, SlotSet):
                    slot = e.key
                    if slot:
                        story_slots.add(slot)

        return story_actions, story_intents, story_slots, story_entities

    async def fetch_domain_items_from_stories(
        self, project_id: Text
    ) -> Optional[Tuple[Set[Text], Set[Text], Set[Text], Set[Text]]]:
        """Fetch set of actions, intents, slots and entities from all stories.

        Returns a tuple of four sets.
        """
        stories = self.fetch_stories()

        if not stories:
            return None

        actions = set()
        intents = set()
        slots = set()
        entities = set()
        for story in stories.result:
            story_events = await self._fetch_domain_items_from_story(
                story["id"], project_id
            )
            actions.update(story_events[0])
            intents.update(story_events[1])
            slots.update(story_events[2])
            entities.update(story_events[3])

        return actions, intents, slots, entities

    async def add_domain_items_for_story(
        self, story_id: Union[int, Text], project_id: Text, username: Text,
    ) -> None:
        """Add story items for `story_id` to domain.

        These are actions, intents, slots and entities.
        """
        story_events = await self._fetch_domain_items_from_story(story_id, project_id)
        await self._add_story_items_to_domain(project_id, username, story_events)

    async def add_domain_items_for_stories(
        self, project_id: Text, username: Text
    ) -> None:
        """Add story items to domain for all stories in database.

        These are actions, intents, slots and entities.
        """
        story_events = await self.fetch_domain_items_from_stories(project_id)
        if story_events:
            await self._add_story_items_to_domain(project_id, username, story_events)

    async def _add_story_items_to_domain(
        self,
        project_id: Text,
        username: Text,
        story_events: Tuple[Set[Text], Set[Text], Set[Text], Set[Text]],
    ):
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain_service.add_items_to_domain(
            project_id,
            actions=story_events[0],
            intents=story_events[1],
            slots=story_events[2],
            entities=story_events[3],
            dump_data=False,
            origin="stories",
        )

    async def update_story(
        self,
        story_id: Text,
        story_string: Text,
        project_id: Text,
        user: Dict[Text, Any],
        update_rule: Optional[bool] = None,
    ) -> Optional[Dict[Text, Any]]:
        """Update properties of a story or a rule.

        Args:
            story_id: ID of story or rule.
            story_string: String contents of story or rule to set.
            project_id: Filter by project ID.
            user: User modifying the story or rule.
            update_rule: If `True`, only search and update rules. If `False`,
                only search and update stories.

        Raises:
            ValueError: If caller attempted to update the contents of a story
                with a rule or vice-versa.

        Returns:
            Updated story/rule in dictionary form, if it was found. Otherwise,
            returns `None`.
        """
        from rasax.community.services.domain_service import DomainService

        domain_service = DomainService(self.session)
        domain = domain_service.get_merged_domain(project_id)

        story_steps = self.get_story_steps(story_string, domain, skip_validation=False)
        if not story_steps:
            return None

        story = self.query(Story).filter(Story.id == story_id)
        if update_rule is not None:
            story = story.filter(Story.is_rule == update_rule)

        story = story.first()

        if not story:
            return None

        if story.is_rule != isinstance(story_steps[0], RuleStep):
            raise ValueError(
                "Can't replace contents of a story with a rule, or vice-versa."
            )

        story.user = user[constants.USERNAME_KEY]
        story.annotated_at = time.time()
        story.name = story_steps[0].block_name
        story.story = story_string.strip()

        # Change filename extension, but keep name the same.
        story.filename = str(Path(story.filename).with_suffix(FileFormat.YAML.value))

        background_dump_service.add_story_change(story.filename)

        await self.add_domain_items_for_story(story_id, project_id, story.user)

        return story.as_dict()

    def dump_stories_to_file_system(
        self, original_story_filename: Text, project_id: Optional[Text] = None
    ) -> None:
        """Dump Rasa Core stories in database to file."""
        if not original_story_filename:
            logger.error("Failed to dump stories to the file: original file not found")

        logger.debug(f"Dumping stories to file '{original_story_filename}'.")
        stories = self.fetch_stories(
            None, filename=original_story_filename, fetch_test_stories=None
        )

        text = self.get_stories_as_string(project_id, stories.result,)

        io_utils.write_file(original_story_filename, text)

    def delete_all_stories(
        self,
        delete_rules: Optional[bool] = None,
        delete_test_stories: Optional[bool] = None,
    ) -> None:
        """Deletes all stories and/or rules.

        Args:
            delete_rules: If `True`, delete only rules. If `False`, delete only stories.
            delete_test_stories: If `True`, delete only test stories. If
                `False`, delete only regular stories.
        """
        query = self.query(Story)

        if delete_rules is not None:
            query = query.filter(Story.is_rule == delete_rules)

        if delete_test_stories:
            query = query.filter(Story.is_test == delete_test_stories)

        query.delete()

    @staticmethod
    def from_request(request: "Request", **kwargs) -> "StoryService":
        """Creates a `StoryService` from an incoming HTTP request's DB session.

        Args:
            request: Incoming HTTP request.
            **kwargs: other key-value args, not used.

        Returns:
            `StoryService` instance with a connection to the DB.
        """
        return StoryService(request.ctx.db_session)
